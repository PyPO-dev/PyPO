<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PyPO User Manual: Gridding And Parameterisations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PyPO User Manual
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('basictut4.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Gridding And Parameterisations </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="basictut4_intro"></a>
Introduction</h1>
<p>In <code>PyPO</code>, there are two common ways to parameterise the surface of a reflector. On this page, we will explain these two parameterisations in more detail. Also, there is a third parameterisation for <code>PyPO</code>, which we will discuss.</p>
<h1><a class="anchor" id="basictut4_xy"></a>
Cartesian Parameterisation</h1>
<p>The Cartesian, or "xy", parameterisation is the most straightforward parameterisation in <code>PyPO</code>. For quadric surfaces it consists of selecting a patch of x and y co-ordinates and evaluating the expression for the quadric surface on this patch in the xy-plane. This generates the z co-ordinates corresponding to the x and y co-ordinate in the xy-plane. For planar geometries, it is even simpler as the z co-ordinate for all x,y in the xy-plane is set to zero.</p>
<p>For a general reflector, the "xy" parameterisation is toggled by passing "xy" to the "gmode" field in a reflector dictionary. After setting this, it is important that the following two fields are also set:</p><ul>
<li>"lims_x" : A Numpy array of length 2, containing the lower and upper limit of the x-range of the parameterisation.</li>
<li>"lims_y" : A Numpy array of length 2, containing the lower and upper limit of the y-range of the parameterisation.</li>
</ul>
<p>See image below for a paraboloid with "gmode" set to "xy" and "lims_x" and "lims_y" both set to <code>numpy.array([-1, 1])</code>. The "pmode" is "manual", with "coeffs" set to <code>numpy.array([1, 1])</code>.</p>
<p><img src="resources/par_xy.png" alt="" class="inline" title="caption"/></p>
<h1><a class="anchor" id="basictut4_uv"></a>
Polar Parameterisation</h1>
<p>The next parameterisation is the polar, or "uv", parameterisation. This parameterisation first takes a (rectangular) patch in the uv-plane, and converts it to a (circular) patch in the xy-plane. The u co-ordinate is the radial part and the v co-ordinate the angular part. Then, the procedure goes along the same lines as for the "xy" parameterisation. This parameterisation is more appropriate for symmetric surfaces of revolution, due to the rotational symmetry present in the parameterisation and reflector.</p>
<p>For a general reflector, the "uv" parameterisation is toggled by passing "uv" to the "gmode" field in a reflector dictionary. After setting this, it is important that the following two fields are also set:</p><ul>
<li>"lims_u" : A Numpy array of length 2, containing the lower and upper limit of the u-range of the parameterisation.</li>
<li>"lims_v" : A Numpy array of length 2, containing the lower and upper limit of the v-range of the parameterisation. In this context, v is defined w.r.t. the positive x-axis and measured in degrees.</li>
</ul>
<p>See image below for the same paraboloid with "gmode" set to "uv" and "lims_u" to <code>numpy.array([0, 1])</code> and "lims_v" set to <code>numpy.array([0, 360])</code>.</p>
<p><img src="resources/par_uv.png" alt="" class="inline" title="caption"/></p>
<h2><a class="anchor" id="basictut4_uv_opts"></a>
Optional Fields For "uv" Parameterisation</h2>
<p>When the "uv" parameterisation is selected, three optional fields become available:</p><ul>
<li>"ecc_uv" : The eccentricity of the resultant circular patch in the xy-plane. Defaults to 0, i.e. a circular patch. If set to a value between 0 and 1, the patch will become elliptic.</li>
<li>"rot_uv" : The position angle of the circular patch in the xy-plane. Obviously, this parameter is only relevant when "ecc_uv" is set to 0. The position angle is defined w.r.t. to positive x-axis.</li>
<li>"gcenter" : A Numpy array of length 2, containing the x and y offset for the xy patch generated from the uv patch.</li>
</ul>
<p>These options are not (yet) available for the "xy" parameterisation.</p>
<p>Of these options, the "gcenter" option plays a special role. Using this field, it is possible to generate off-axis reflectors from a circular xy patch. This is interesting from the perspective of, for example, radio telescope designers, as off-axis designs have the advantage of having less feed/secondary support strut blockage.</p>
<p>See image below for the same paraboloid with "gcenter" set to <code>numpy.array([0.5, 0.5])</code>.</p>
<p><img src="resources/par_uv_gc.png" alt="" class="inline"/></p>
<p>See image below for the same paraboloid with "ecc_uv" set to 0.7 and "rot_uv" set to 45 degrees. The "gcenter" is set to the origin again.</p>
<p><img src="resources/par_uv_07_45.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="basictut4_AoE"></a>
"AoE" (Azimuth Over Elevation) Parameterisation</h1>
<p>The final parameterisation type is the Azimuth-over-Elevation, or "AoE", parameterisation. This parameterisation is exclusive to planar geometries. The parameterisation is necessary for defining far-field elements. When a far-field beam pattern is calculated on an "AoE" parameterised surface, <code>PyPO</code> internally converts the Azimuth and Elevation angles to direction cosines on-sky and calculates the far-field.</p>
<p>In order to define a plane in the far-field, set the "gmode" field to "AoE" and make sure the following fields are present in the reflector dictionary:</p><ul>
<li>"lims_Az" : A Numpy array of length 2, containing the lower and upper limits on the Azimuthal angle. The angle is in degrees and is defined w.r.t. the x-axis.</li>
<li>"lims_El" : A Numpy array of length 2, containing the lower and upper limits on the Elevation angle. The angle is in degrees and is defined w.r.t. the z-axis.</li>
</ul>
<p>Note that the grid generated by this parameterisation is angular instead of spatial. Translating this grid therefore does not displace it, but rather changes the direction in which the far-field is calculated.</p>
<h1><a class="anchor" id="basictut4_gridsize"></a>
Setting The Gridsizes</h1>
<p>Before a reflector dictionary is accepted by the <code>System</code>, one final field needs to be specified: the "gridsizes" field. This field is a Numpy array of length 2 and defines the amount of cells along the x/u/Az and y/v/El axes. This field is therefore very important, as using values that are insufficiently accurate might result in nonsensical results. the best way to find good values for this field is by experimenting a bit and seeing what works through trial-and-error, because finding a rigorous one-stop solution for determining this is relatively hard.</p>
<p><code>PyPO</code> does contain an aid, however, in the form of the <code>autoConverge()</code> method, present in <code>System</code>. For this method to work, a PO field should be present as well as the target surface onto which the field is to be propagated. This method is still quite experimental, but has shown to work relatively well in the few situations it has been tested. Nevertheless, the "gridsizes" field should be set carefully, and users should investigate the correctness of their simulation by tweaking these values yourself. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
